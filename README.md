# Protostar exploits ðŸŒ â˜ ï¸
> Solutions for protostar challenges

When I first started protostar I couldn't do shit

## Basics

### 1. GDBs
This debugger "allows you to see what is going on 'inside' another program while it executes" [GNU Project](https://www.gnu.org/software/gdb/).
To execute it over a program, run:
```
$ gdb stack0
```
The first thing we will probably wanna do is to get the assembly code of the program. To do so, we will need to pick a side AT&T or Intel (I'm team Intel) and set up the disassembly syntax:
```
(gdb) set disassembly-flavor intel
```
Proceed to disassemble the main function with:
```
(gdb) disassembly main
```
And we will see something like this:
```
Dump of assembler code for function main:          
0x080483f4 <main+0>:    push   ebp    
0x080483f5 <main+1>:    mov    ebp,esp    
0x080483f7 <main+3>:    and    esp,0xfffffff0    
0x080483fa <main+6>:    sub    esp,0x60
0x080483fd <main+9>:    mov    DWORD PTR [esp+0x5c],0x0
0x08048405 <main+17>:    lea    eax,[esp+0x1c]
0x08048409 <main+21>:    mov    DWORD PTR [esp],eax
0x0804840c <main+24>:    call   0x804830c <gets@plt>
0x08048411 <main+29>:    mov    eax,DWORD PTR [esp+0x5c]
0x08048415 <main+33>:    test   eax,eax
0x08048417 <main+35>:    je     0x8048427 <main+51>
0x08048419 <main+37>:    mov    DWORD PTR [esp],0x8048500
0x08048420 <main+44>:    call   0x804832c <puts@plt>
0x08048425 <main+49>:    jmp    0x8048433 <main+63>
0x08048427 <main+51>:    mov    DWORD PTR [esp],0x8048529
0x0804842e <main+58>:    call   0x804832c <puts@plt>                
0x08048433 <main+63>:    leave
0x08048434 <main+64>:    ret
```
This code here (that goes from `0x080483f4` to `0x08048434`) belogns to the `.text` segment as long as other compiled functions. Basically there are [5 different segments](https://en.wikipedia.org/wiki/Data_segment): `.text`, `.data`, `.bss`, `heap`, `stack`.

You can examine any hex address or registry by using this synxtax:
```
(gdb) x/32 $esp
```
This means examine(`x/`) and print 32 bytes (`32`) from the registry `$esp`

It could also show addresses, for example:
```
(gdb) x/32 0x80483f4
```

There are also a concept called breakpoint. A breakpoint is a stop in a certain point of the program when it's running. For example we are going to stop at the first instruction, so out breakpoint would be:
```
(gdb) b * 0x080483f4
```

And then, in order to run the program just:
```
(gdb) r
```
You will notice right away that the program stops with a message like this:
```
Starting program: /opt/protostar/bin/stack0
Breakpoint 1, main (argc=1, argv=0xbffff814) at stack0/stack0.c:6
6       stack0/stack0.c: No such file or directory.
		in stack0/stack0.c
```
This means the program stopped at the breakpoint and now you can examine all registries and addresses at that point of the program.

### 2. Registries

### 2. Stack
- Is an [abstract data type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) which has 2 operations `push` and `pop`.
- Used for memory management. Operating System provides one for each process running.